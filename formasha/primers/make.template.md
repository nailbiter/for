# основы make'а


## Занятие #1

### немного практики

`make` -- это система автоматизации сборки проектов. 

Что это означает? Допустим, у тебя есть проект, состоящий из трех файлов: 

`main.c`:
```c
[% INCLUDE main.c %]
```

`header.h`:
```c
[% INCLUDE header.h %]
```

`code.c`:
```c
[% INCLUDE code.c %]
```

Как мы его компилируем?

```sh
gcc -o main -std=c99 main.c code.c
```

Теперь допустим, что мы хотим поменять только *один из* файлов, к примеру только `main.c`. При этом, нам нужно будет перекомпилировать
оба файла командой `gcc -o main -std=c99 main.c code.c`. Если оба файла очень большие, это может привести к заметным задержкам и хотелось
бы чтобы можно было компилировать их отдельно, а потом просто "слепить" вместе. Это можно устроить:

```sh
	gcc -o main.o -std=c99 main.c -c
	gcc -o code.o -std=c99 code.c -c
	gcc -o main main.o code.o
```

Первая строчка компилирует `main.c` *отдельно*, вторая -- `code.c`, третья *лепит* их вместе.
Теперь, если поменялся только `code.c`, то выполнять нужно только вторую и третью строчку, но не первую.

### немного теории

Обрати внимание на ключ `-c` в первых двух из последних трех комманд. Именно этот ключ говорит компилятору, что компилировать
нужно "не до конца". Говоря более точно, компилятор в присутствии этого ключа создает только *объектный файл*, а не *исполняемый*
(потому и расширение `.o` в `main.o` и `code.o`), а потом эти объектные файлы уже склеиваются в один исполняемый.

Фишка в том, что компиляция в объектные файлы -- сравнительно дорогая операция, так как она реально требует перевода из Си
в машинный код, а вот "слепка" объектников и исполняемый файл -- дешевая, так как никаких "языковых способностей" тут не требуется.

## Занятие #2

### немного практики

С подходом, приведенным в приведыщем параграфе, сопряжены некоторые проблемы. Первое, вводить три команды лениво. Более того, нужно
помнить, при каких ситуациях какие команды вводить нужно, а какие -- нет. Например, если поменялся только `main.c`, то нужны только первая
и третья команды, но не вторая; если только `code.c`, то только вторая и первая; а вот если `header.h`, то нужны все три. Это становится
немного сложным.

`make` спешит на помощь! Создаем файл `Makefile` с содержанием:

```
main.o: main.c header.h
	gcc -o main.o -std=c99 main.c -c
code.o: code.c header.h
	gcc -o main.o -std=c99 code.c -c
main:main.o code.o
	gcc -o main main.o code.o
```

Теперь для компиляции достаточно исполнить всего одну команду: `make main`.

### немного теории

При исполнении команды `make <someting>` происходит следующее:

1. `make` ищет файл `Makefile` в текущей директории
1. если файл не находится, выдается ошибка
1. если файл находится, `make` читает из него *правила*
1. `make` пользуется правилами, чтобы сделать (отсюда и название программы) `<something>`

#### Правила 

В общем виде, `Makefile` состоит из набора *правил*. Правила записываются в виде

```
target: prereq1 prereq2 ...
	recipe1
	recipe2
  ...
```

к примеру, в предыдущем `Makefile` было три правила. Рассмотрим первое:

```
main.o: main.c header.h
	gcc -o main.o -std=c99 main.c -c
```

В этом правиле `main.o` называется *целью*, а `main.c` и `header.h` -- *зависимостями*. После `main.o: main.c header.h`
будет идти одна или несколько строчек начинающихся с таба: это *рецепт*.

**Важно!** Все команды рецепта должны начинаться с таба, а НЕ с пробелов.

Данное правило говорит `make`'у, как сделать `main.o` если у него уже есть `main.c` и `header.h`. `make` просто исполняет
команды из рецепта, одну за другой. Так же, это говорит `make`'у, что если зависимости НЕ обновились (он проверяет это по отметке
последней модификации файла), то цель можно НЕ переделывать.

`make` рассматривает правила *рекурсивно*, что позволяет ему понять, что для того, чтобы сделать файл `main` (а именно это ты просишь
его сделать командой `make main`), нужно сделать `main.o` и `code.o`, а потом из них уже сам `main`.
