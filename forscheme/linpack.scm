(setlocale LC_ALL "")
;(include "misc.scm")

;naive lin algebra
(define (list->mat l) (define dim (sqrt (length l)))
  (cond ((eq? (car l) 'ns) (let((m (cadr l))
                                   (n (caddr l))
                                   (M (cdddr l))
                                   )
                                  (partite (dup n m) M)))
        ((integer? dim) (let ((edim (inexact->exact dim)))(partite (dup edim edim) l)))
        (#t '())))
(define (signswitch . z)
	(define (inner2 l ctr) (if (null? l) '() (cons (if (even? ctr) (car l) (* -1 (car l))) (inner2 (cdr l) (+ ctr 1)))))
	(define (inner1 l) (inner2 l 0))
	(cond ((eq? (length z) 1) (inner1 (car z))) ((eq? (length z) 2) (inner2 (car z) (car(cdr z))))))
(define (det m) (if (= (length m) 1) (caar m)
		  (sum (map * (signswitch (car m)) 
		(map det (map 
			       (lambda (num) (map (lambda (l) (remove-elem l num)) (cdr m)))
			       (seq 0 (length (car m))) 
			       ))))))
(define (replace-col M num b) (map (lambda (l b-elem) (replace-elem l num b-elem)) M b))
(define (remove-matrix-rowcol m rownum colnum) (map (lambda (l) (remove-elem l colnum)) (remove-elem m rownum)))
(define (transpose m) (map (lambda (i) (map (lambda (l) (select l i)) m)) (seq 0 (length m))))
(define(matr-prod . l)
  (fold-right(lambda(A B)(if(eq? B 'id)A(map(lambda(row)(map(lambda(rowB)(fold + 0 (map * rowB row)))(transpose B)))A)))'id l))
(define(matr-sum . l)(fold-right(lambda(A B)(if(eq? B 'id)A(map (lambda (r1 r2)(map + r1 r2)) A B)))'id l))

;printing procedures
(define (number->string/latex num)(cond((integer? num)(format #f "~d" num))((rational? num)(let((num(numerator num))
    (den(denominator num)))(string-concatenate(list (if(> 0 num)"-" "")(format #f "\\mysfrac{~d}{~d}" (abs num) den)))))))
(define (matrix->string/latex . args)(let*((M(car args))
					   (dels(cond((eq?(cdr args)'())(cons"("")"))((eq?(cadr args)'d)(cons"|""|"))))
					   (del1(car dels))(del2(cdr dels)))
			       (string-concatenate(list(format #f "\\left~a\\begin{array}{" del1)
			       (string-concatenate(map (lambda (n) (format #f "r")) (seq 0 (length (car M)))))
			       (format #f "}\n")
			       (string-concatenate(map(lambda(row)(string-concatenate(list(string-concatenate(cons(number->string/latex (car row))
			       (map (lambda (e) (string-concatenate(list "&"(number->string/latex e))))(cdr row))))(format #f "\\\\\n"))))M))
			       (format #f "\\end{array}\\right~a\n" del2)
			       ))))
(define (augmented-matrix->string/latex M aug-cols) (string-concatenate(list(format #f "\\left(\\begin{array}{")
			       (string-concatenate(map (lambda (n) (format #f "r")) (seq 0 (- (length (car M)) aug-cols))))(format #f "|")
                   		(string-concatenate(map (lambda (n) (format #f "r")) (seq 0 aug-cols)))
			       (format #f "}\n")
			       (string-concatenate(map(lambda(row)(string-concatenate(list(string-concatenate(cons(number->string/latex (car row))
			       (map (lambda (e) (string-concatenate(list "&"(number->string/latex e))))(cdr row))))(format #f "\\\\\n"))))M))
			       (format #f "\\end{array}\\right)\n")
			       )))
(define (matrix->string/txt M)(string-concatenate(map(lambda(row)(string-append
					(string-concatenate(map(lambda(e)(format #f "~/~a" e))row))"\n"))M)))

;Gaussian elimination
(define (GE matrix executor) (define (GE-inner matrix-inner executor-inner) 'TODO)
  (GE-inner matrix (executor (list 'init matrix))))
(define (make-executor init methods) (lambda (op) (make-executor (methods init op) methods)))
;GE->print_executor->bring_to_rowechelon

(define A (list->mat(list 2 1 2 1 3 0 1 1 -1 2 -2 1 -3 2 3 1)))
(define C(list->mat(list 1 0 -1 1)))
(define D(list->mat(list 2 0 0 2)))
(define E(list->mat(list 0 1 1 0)))
(define B11(list->mat(list 1 1 1 2)))
(define B12(list->mat(list 1 1 1 1 )))
(define B21(list->mat(list 3 1 3 2)))
(define B22(list->mat(list 1 1 1 2)))
;(map(lambda(B)(begin(display(matrix->string/txt(matr-prod C B)))(newline)))(list B11 B12 B21 B22))
(define AA (remove-matrix-rowcol A 1 0))
(define AB (remove-matrix-rowcol A 1 2))
(define AC(remove-matrix-rowcol A 1 3))
(map(lambda(M)
      (let* ((a1 (car(car M)))
	     (a2(-(cadr(car M))))
	     (a3(caddr(car M)))
	     (A1(remove-matrix-rowcol M 0 0))
	     (A2(remove-matrix-rowcol M 0 1))
	     (A3(remove-matrix-rowcol M 0 2))
	     (dummy (display "\\[+\\mybra{"))
	     (myprint(lambda(Ax ax)(begin(if(> ax 0)(display "+"))(display ax)(display (matrix->string/latex Ax 'd)))))
	     (dummy (map myprint (list A1 A2 A3)(list a1 a2 a3)))
	     (dummy (display "}+\\]\n"))
	     )'())
      )(list AB AC))
(display (det AA))(newline)
(display (det AB))(newline)
(display (det AC))(newline)
(display (det A))
(exit)

;driver&engine script
(define A (list->mat(list 'ns 3 6 1 0 1 1 0 0 -1 1 1 0 1 0 -1 -2 -3 0 0 1)))
((if #t (lambda(M)(begin(display "\n\\[")(display(matrix->string/latex(map(lambda(row)(list-tail row(/(length row)2)))M)))(display "\\]\n")))
(lambda(M)(display "\n")(display(matrix->string/txt M))))
      (fold (lambda (op mat) (let* ((res (cond 
                                    ((eq?(car op)'m) (let*((rownum(list-ref op 1)) (row(list-ref mat rownum)) (mult(list-ref op 2)))
                                                              (replace-elem mat rownum (map (lambda (c) (* c mult)) row))))
                                    ((eq?(car op)'i)(let*((i1 (cadr op))(i2 (caddr op))(r1 (list-ref mat i1))(r2(list-ref mat i2)))
                                                        (replace-elem (replace-elem mat i1 r2) i2 r1)))
                                    ((eq?(car op)'s)(let*((i1(cadr op))(i2(caddr op))(m (cadddr op))(r1(list-ref mat i1)))
                                                      (replace-elem mat i2 (map (lambda (a b)(- b(* m a) )) r1 (list-ref mat i2)))))
                                    (#t mat)))
                                    (aug-col (/ (length (car mat)) 2))
                                    (dummy (format #t "\\["))
                                    (dummy (display (augmented-matrix->string/latex mat aug-col)))
                                    (dummy (cond 
                                    ((eq?(car op)'m) (let*((rownum(list-ref op 1)) (mult(list-ref op 2)))
                                                  (format #t"\\xrightarrow{\\text{$~a*$\\textcircled{~d}}}"(number->string/latex mult)(inc rownum))))
                                    ((eq?(car op)'i)(let*((i1 (inc(cadr op)))(i2 (inc(caddr op))))
					(format #t"\\xrightarrow{\\text{\\textcircled{~d}\\leftrightarrow\\textcircled{~d}}}" i1 i2)))
                                    ((eq?(car op)'s)(let*((i1(inc(cadr op)))(i2(inc(caddr op)))(m (-(cadddr op))))(format #t
              			    "\\xrightarrow{\\text{\\textcircled{~d}$~a~a*$\\textcircled{~d}}}"i2(if(> m 0)"+""")(number->string/latex m)i1)))
                                    (#t '())
                                    ))
                                    (dummy (display (augmented-matrix->string/latex res aug-col)))
                                    (dummy (format #t "\\]")))
                         res
                             )) A (list (list 's 0 1 -1)
					(list 's 0 2 -1)
					(list 's 1 2 -2)
				    	(list 'm 2 1/2)
					(list 's 2 1 2)
				    	;(list 's 2 0 5/2)
				    	;(list 'm 0 2)
                                        ;(list 'i 1 0)
                                        ;(list 'm 0 2)
                                        ;(list 'm 1 -2)
                                        )))(newline)
(exit)

